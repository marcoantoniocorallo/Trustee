- All'interno dei trusted blocks è possibile utilizzare let expressions e handle.
  Avrei potuto utilizzare una nuova categoria sintattica nel parser per evitare la possibilità
  di dichiarare nested trusted blocks già nel front-end, ma avrei potuto comunque definire roba del tipo
  let data = let trust { ... } in 
  Il front-end avrebbe eliminato il problema in superficie, ma all'interno di espressioni avrei
  comunque il problema. Quindi ho preferito avere categorie sintattiche più semplici (e in minor numero)
  e gestirlo durante la fase di type checking

- la keyword "secret" è invece utilizzabile solo all'interno di un blocco trust

- Ogni dichiarazione (Let ... ) all'interno di un blocco trusted è privata by-default;
  Le funzioni all'interno di un costrutto Handle vengono poi ri-aggiunte all'ambiente con qualificatore
  Public, sfruttando lo shadowing

- Solo i dati possono essere dichiarati secret, non le funzioni

- Le funzioni dichiarate all'interno di un blocco handle devono essere già state definite nel blocco
  e devono quindi avere un nome. 
  In particolare, nel blocco handle si possono solo inserire nomi di funzioni, non altre espressioni

- Blocco handle mandatory

- Trusted Block value non-printable (opaque)

- Trusted blocks NON sono cittadini di prima classe! 
  i.e. Non possono essere usati come argomenti di funzioni o restituiti
  Non sarebbe complicato estendere il linguaggio per trattare come first-class citizen i blocchi,
  basterebbe equipaggiarlo di type annotations, definire la relazione di ordinamento tra tipi <=
  in modo pointwise (field-per-field)

- I plugin possono invece essere passati come funzioni o come valori di ritorno, essendo funzioni
  La relazione di ordinamento tra plugin segue quella delle funzioni che wrappano infatti

- mostrare la grammatica del linguaggio e dei blocchi

- I plugin possono essere inclusi, ma per rafforzare l'access control la direttiva include 
  prende solo nomi di files dentro plugin.

- La direttiva include fa dei controlli sulla cartella sorgente del file da includere e 
  sul tipo di espressione parsata: solo la dichiarazione di un plugin può essere parsata!

- Nota: INCLUDE fa preprocessing, parsa il file e lo carica!

- Nella mia visione di plugin, questi sono blocchi di codice (dati + funzioni) inaccessibili.
  Il codice del plugin viene valutato solo tramite apposita chiamata unsafe_eval
  Immagino che quando si scarichi/acquisti un plugin, questo sia corredato da un insieme di informazioni
  plugin filter:
  @provides string_f : (string -> bool) -> string list -> string list 
  di controllare che venga utilizzato correttamente se ne occupa il type checker

- Includere nelle design choices le scelte di valutazione della taintness per ogni espressione

- Se dovesse chiederlo: la DTA è fatta a run-time (e non a type-checking, ammess che si possa) perchè
  le assert lavorano sul run-time, quindi ci interessa avere le informazioni sulla taintness a rt

- I controlli sugli accessi e la visibilità degli attributi secret sono statici:
  nel type checking contrlliamo che dato un blocco trusted, solo funzioni vengano esportate,
  che non si tenti di accedere a variabili secret e che all'interno di blocchi trusted non si acceda
  a plugin.

- Trusted blocks non esegue plugin all'interno

- Il codice plugin NON può accedere a variabili esterne.

- I plugin devono essere valutati come funzioni

- I plugin vengono invocati come normali funzioni, preceduti dalla keyword unsafe.
  Se la keyword non viene utilizzata, il type checker fallisce perchè trova un plugin inatteso.

- Se dovesse chiederlo: quando una funzione taint viene invocata il programma non abortisce.
  Infatti, non potendo modificare la memoria, l'unico tipo di funzione taint sono i plugin