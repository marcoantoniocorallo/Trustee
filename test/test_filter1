  // Type System prevents data leakage
    let trust pwd = {
      let secret pass = "abcd" in 

      let fun checkpwd (guess : string) : bool = 
        declassify(pass = guess) in

      handle: {checkpwd}
    } in
    let filter = <"filter"> in

    // data leak (prevented): filter interact with trusted block
    // filter pwd.checkpwd ["pippo", "abc", "abcd", "pluto", "paperino"]
    
    // no data leak: filter doesn't interact with secret data/function
    // filter (lambda (x:string) : bool -> x="abcd") ["pippo", "abc", "abcd", "pluto", "paperino"]

    (*
    // In this scenario the filter function is implemented inside of a trusted block;
    // the two trusted blocks are able to interact and the password could be leaked,
    // but it is an artificial scenario: trusted block are known and trusted by the user
    // that is the opposite of plugin, that can hide threats.
    let trust filter1 = {
      let fun string_f (predicate : string -> bool) (l : string list) : string list = 
        if l = [] then [] 
        else if predicate (hd l) then (hd l)::(string_f predicate (tl l))
        else (string_f predicate (tl l))
      in 
      handle:{string_f}
    } in
    filter1.string_f pwd.checkpwd ["pippo", "abc", "abcd", "pluto", "paperino"]
    *)